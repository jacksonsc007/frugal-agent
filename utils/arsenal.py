from typing import Annotated
from openai import OpenAI
from openai.lib.streaming.chat._completions import ChatCompletionStreamState
import openai
import json
import re
import os
from utils.logger.logger import mylogger as logger

"""
The following functions are fake / incomplete, only used in training and reward evaluation to validate the correctness of tool calls generated by models.
"""
def question_answer_expert(query: str):
    """An expert excels at providing detailed explanations and answers to questions.
    Args:
        query: The question users have ask.

    Returns:
        str: The detailed answer to the question.
    """
    return ""


def format_organizer(
    instruction: Annotated[str, "The instruction users input"],
    response: Annotated[str, "The corresponding response from the LLM"],
):
    """An Organizer which organize instruction and response pairs into specific format.
    Args:
        instruction: The instruction users input.
        response: The corresponding response from the LLM.

    Returns:
        str: The organized instruction and response pairs.
    """
    return ""


def save_file(
    file_name: Annotated[str, "The name of file to be saved"],
    content: Annotated[str, "The content of the file to be saved"],
):
    """Save a file
    Args:
        file_name: The name of file to be saved.
        content: The content of the file to be saved.

    Returns:
        str: The result of saving the file
    """
    try:
        if not (output_dir := os.getenv("OUTPUT_DIR")):
            output_dir = "outputs"
        from datetime import datetime

        timestamp = datetime.now().strftime("%Y-%m-%d_%H")
        output_dir = os.path.join(output_dir, "saver", timestamp)
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        with open(os.path.join(output_dir, file_name), "w") as file:
            file.write(content)
        # print(f"File {file_name} saved successfully")
        res = f"File {file_name} saved successfully"
    except Exception as e:
        res = f"An error happened when saving the file: {e}"
        logger.error(res)
    return res


TOOLS_NAMES = ["question_answer_expert", "format_organizer", "save_file"]
TOOLS = [
    {
        "type": "function",
        "function": {
            "name": "question_answer_expert",
            "description": "An expert excels at providing detailed explanations and answers to questions.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The question users have ask.",
                    }
                },
                "required": ["query"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "format_organizer",
            "description": "An Organizer which organize instruction and response pairs into specific format.",
            "parameters": {
                "type": "object",
                "properties": {
                    "instruction": {
                        "type": "string",
                        "description": "The instruction users input.",
                    },
                    "response": {
                        "type": "string",
                        "description": "The corresponding response from the LLM.",
                    },
                },
                "required": ["instruction", "response"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "save_file",
            "description": "Save a file",
            "parameters": {
                "type": "object",
                "properties": {
                    "file_name": {
                        "type": "string",
                        "description": "The name of file to be saved",
                    },
                    "content": {
                        "type": "string",
                        "description": "The content of the file to be saved",
                    },
                },
                "required": ["file_name", "content"],
            },
        },
    },
]

# Existing tool functions (question_answer_expert, format_organizer, save_file)
# Keep all your existing tool function definitions here


def get_function_by_name(name):
    return {
        "question_answer_expert": question_answer_expert,
        "format_organizer": format_organizer,
        "save_file": save_file,
    }.get(name)


def try_parse_tool_calls(content: str):
    """
    Try parse the tool calls from the model's reponse.
    This function is modifed to be compatible with vllm, which require func["arguments"] to be string instead of dict
    """
    tool_calls = []
    offset = 0
    pattern = r"<tool_call>\n(.+?)\n</tool_call>"
    for i, m in enumerate(re.finditer(pattern, content, flags=re.DOTALL)):
        if i == 0:
            offset = m.start()
        try:
            func = json.loads(m.group(1), strict=False)
            tool_calls.append({"type": "function", "function": func})
            # if isinstance(func.get("arguments"), dict):
            #     func["arguments"] = json.dumps(func["arguments"])
        except Exception as e:
            logger.info(f"Failed to parse tool calls from model reponses.")
            logger.debug(f"Model reponse:\n {m.group(1)}.\n{e}")
    if tool_calls:
        # sort dependent tool calls
        if all(
            tool_call.get("function").get("call_sequence_id")
            for tool_call in tool_calls
        ):
            try:
                tool_calls = sorted(
                    tool_calls,
                    key=lambda x: x.get("function", {}).get("call_sequence_id", 0),
                )
            except Exception as e:
                logger.critical(
                    f"Failed to sort tool calls according to call sequence id: {e}\033[0m"
                )
        if offset > 0 and content[:offset].strip():
            c = content[:offset]
        else:
            c = ""
        # NOTE: The messages should only contain string, we need to convert dict back to string
        for tool_call in tool_calls:
            func = tool_call.get("function")
            if isinstance(func.get("arguments"), dict):
                func["arguments"] = json.dumps(func["arguments"])
        return {"role": "assistant", "content": c, "tool_calls": tool_calls}
    return {"role": "assistant", "content": re.sub(r"<\|im_end\|>$", "", content)}

"""
Replace placeholders (e.g., {1.output}) with actual outputs.
"""
def try_parse_intermediate_representation(args, dependent_tool_output_dict):
    for key, value in args.items():
        if isinstance(value, str):
            if match := re.search(r"\{(\d+)\.output\}", value):
                call_sequence_id = int(match.group(1))
                call_output = dependent_tool_output_dict.get(call_sequence_id, None)
                if call_output is None:
                    logger.warning(f"Output for call id {call_sequence_id} missing")
                else:
                    logger.info(
                        f"Found output for call id {call_sequence_id} in the record."
                    )
                args[key] = re.sub(r"\{(\d+)\.output\}", call_output, value)
    return args


def try_invoke_tool_calls(assistant_message: dict, dependent_tool_output_dict: dict):
    tool_call_valid = []
    tool_name = []
    tool_args = []
    tool_responses = []
    tool_call_ids = []
    if "tool_calls" in assistant_message:
        for tool_call in assistant_message["tool_calls"]:
            is_valid, fn_name, fn_args, fn_result = try_invoke_tool(tool_call)
            tool_call_valid.append(is_valid)
            tool_name.append(fn_name)
            tool_args.append(fn_args)
            tool_responses.append(fn_result)
    return tool_call_valid, tool_name, tool_args, tool_call_ids, tool_responses


def try_invoke_tool(tool_call: dict):
    fn_name = None
    fn_args = None
    fn_result = None
    is_valid = False
    try:
        fn_name = tool_call["function"]["name"]
        if isinstance(tool_call["function"]["arguments"], dict):
            fn_args = tool_call["function"]["arguments"]
        else:
            # logger.warning(f"In this version, tool call {tool_call} is using dict for arguments rather than string")
            fn_args = json.loads(tool_call["function"]["arguments"], strict=False)
            call_sequence_id = tool_call["function"].get("call_sequence_id", "")
            if call_sequence_id != "" and not isinstance(call_sequence_id, int):
                logger.warning(
                    f"The sequence id generated by model is not integer: {call_sequence_id}"
                )
    except Exception as e:
        logger.critical(
            f"Tool call format is not a valid json, please check `try_parse_tool_calls`. Invalid tool calls should not enter this part: {tool_call}\n {e}"
        )
        exit(1)
    try:
        fn = get_function_by_name(fn_name)
        fn_result = fn(**fn_args)
        is_valid = True
    except Exception as e:
        logger.info(f"The model response is a valid json, but not valid function args")
        logger.debug(f"function name: {fn_name} arguments: {fn_args} error: {e}")
    return is_valid, fn_name, fn_args, fn_result
